#!/usr/bin/python3

import base64
import errno
import getpass
import os
import subprocess
import sys
import tempfile


def error(message, exitstatus=4):
    print("error:", message, file=sys.stderr)
    sys.exit(exitstatus)


def usage(error=""):
    if error:
        print("error:", error, file=sys.stderr)
    print(
        """usage:

qvm-mount-folder <VM> <folder from VM> <mountpoint>""",
        file=sys.stderr if error else sys.stdout,
    )
    sys.exit(os.EX_USAGE)


try:
    vm, source, target = sys.argv[1:4]
except IndexError:
    usage("invalid arguments")


if not os.path.isdir(target):
    error("%s does not exist or is not a directory" % target)

vm_encoded = base64.standard_b64encode(vm.encode("utf-8"))
folder_encoded = base64.standard_b64encode(source.encode("utf-8"))

# Request authorization for a specific folder (and its subfolders)
# on a particular VM.  If the authorization is successful, a
# ticket called a "fingerprint" is returned, which entitles this
# program to access the folder (either one-time or permanently,
# as the user has decided).
p = subprocess.Popen(
    ["qrexec-client-vm", "dom0", "ruddo.AuthorizeFolderAccess"],
    stdin=subprocess.PIPE,
    stdout=subprocess.PIPE,
    bufsize=0,
    close_fds=True,
)
p.stdin.write(vm_encoded + b"\n")
p.stdin.write(folder_encoded + b"\n")
p.stdin.close()
fingerprint = p.stdout.read()
p.stdout.close()
ret = p.wait()

if ret != 0:
    if ret == errno.EACCES:
        print("Request denied", file=sys.stderr)
    elif ret == errno.EINVAL:
        print("Invalid parameters", file=sys.stderr)
    else:
        print("Unknown error", file=sys.stderr)
    sys.exit(ret)

f1_read, f1_write = os.pipe2(0)
f2_read, f2_write = os.pipe2(0)

stdin_for_read = os.fdopen(f1_read, "rb", buffering=0)
stdout_for_write = os.fdopen(f2_write, "wb", buffering=0)
stdin_for_write = os.fdopen(f1_write, "wb", buffering=0)
stdout_for_read = os.fdopen(f2_read, "rb", buffering=0)

# With the fingerprint, use it to invoke the RPC service that was
# just authorized for this script.
p = subprocess.Popen(
    ["qrexec-client-vm", vm, "ruddo.ConnectToFolder+%s" % fingerprint.decode("utf-8")],
    stdin=stdin_for_read,
    stdout=stdout_for_write,
    bufsize=0,
    close_fds=True,
)
stdin_for_read.close()
stdout_for_write.close()

# Now send the folder we intend to mount, which may be
# a subfolder of the requested folder.  This is thought
# so that e.g. permanent authorization for /home/user works to
# grant authorization for a mount request of /home/user/subfolder.
# The receiver will check if this script is not "cheating",
# id est, if the folder I am passing here is the same folder
# used to obtain the fingerprint above, or at least a subfolder
# of it.
stdin_for_write.write(folder_encoded + b"\n")
response = stdout_for_read.read(3).decode("utf-8").rstrip()
if response == "ok":
    # Proceed.  We have received authorization and diod has
    # already started on the other side.
    pass
elif response == "":
    # folder does not exist
    exit = p.wait()
    if exit == 2:
        error("directory %s does not exist in qube %s" % (source, vm), errno.ENOENT)
    elif exit == 13:
        error(
            "qube %s has denied the mount request for directory %s" % (vm, source),
            error.EACCES,
        )
    elif exit == 126:
        error(
            "qrexec policy has denied the mount request to %s for directory %s"
            % (vm, source),
            126,
        )
    else:
        error("unknown exit status %s" % exit, exit)
else:
    p.kill()
    assert 0, "not reached: %r" % response

uid = os.getuid()
gid = os.getgid()
username = getpass.getuser()
cmdline = [
    "/usr/bin/sudo",
    "/usr/bin/mount",
    "-t",
    "9p",
    "-o",
    "trans=fd,rfdno=%s,wfdno=%s,version=9p2000.L,dfltuid=%s,dfltgid=%s,uname=%s,aname=%s"
    % (0, 1, uid, gid, username, source),
    "qvm://%s%s" % (vm, source),
    target,
]

p2 = subprocess.Popen(
    cmdline, stdin=stdout_for_read, stdout=stdin_for_write, close_fds=True
)
stdout_for_read.close()
stdin_for_write.close()

sys.exit(p2.wait())
